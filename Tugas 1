#Caesar Cipher
def caesar_encrypt(text, key):
    result = ""
    for char in text.upper():
        if char.isalpha():
            result += chr((ord(char) - 65 + key) % 26 + 65)
        else:
            result += char
    return result
    
#Vigenere Cipher
def vigenere_encrypt(text, key):
    text = text.upper().replace(" ", "")
    key = key.upper()
    result = ""
    for i, char in enumerate(text):
        shift = ord(key[i % len(key)]) - 65
        result += chr((ord(char) - 65 + shift) % 26 + 65)
    return result
    
#Affine Cipher
def mod_inverse(a, m):
    for i in range(m):
        if (a * i) % m == 1:
            return i
    return None

def affine_encrypt(text, a, b):
    result = ""
    for char in text.upper():
        if char.isalpha():
            result += chr(((a * (ord(char) - 65) + b) % 26) + 65)
        else:
            result += char
    return result

#Playfair Cipher
def generate_playfair_matrix(key):
    key = key.upper().replace("J", "I")
    matrix = []
    for c in key:
        if c not in matrix and c.isalpha():
            matrix.append(c)
    for c in "ABCDEFGHIKLMNOPQRSTUVWXYZ":
        if c not in matrix:
            matrix.append(c)
    return [matrix[i:i+5] for i in range(0, 25, 5)]

def find_position(matrix, letter):
    for i, row in enumerate(matrix):
        if letter in row:
            return i, row.index(letter)

def playfair_encrypt(text, key):
    matrix = generate_playfair_matrix(key)
    text = text.upper().replace("J", "I").replace(" ", "")
    pairs = []
    i = 0
    while i < len(text):
        a = text[i]
        b = text[i+1] if i+1 < len(text) else "X"
        if a == b:
            b = "X"
        pairs.append((a, b))
        i += 2
    result = ""
    for a, b in pairs:
        row_a, col_a = find_position(matrix, a)
        row_b, col_b = find_position(matrix, b)
        if row_a == row_b:
            result += matrix[row_a][(col_a + 1) % 5]
            result += matrix[row_b][(col_b + 1) % 5]
        elif col_a == col_b:
            result += matrix[(row_a + 1) % 5][col_a]
            result += matrix[(row_b + 1) % 5][col_b]
        else:
            result += matrix[row_a][col_b]
            result += matrix[row_b][col_a]
    return result

#Hill Cipher
import numpy as np

def hill_encrypt(plaintext, key_matrix):
    plaintext = plaintext.upper().replace(" ", "")
    while len(plaintext) % 2 != 0:
        plaintext += 'X'
    result = ""
    for i in range(0, len(plaintext), 2):
        vector = np.array([[ord(plaintext[i]) - 65], [ord(plaintext[i+1]) - 65]])
        encrypted = np.dot(key_matrix, vector) % 26
        result += chr(int(encrypted[0][0]) + 65)
        result += chr(int(encrypted[1][0]) + 65)
    return result

#Uji Coba Program (Contoh)
if __name__ == "__main__":
    print("=== Caesar Cipher ===")
    print(caesar_encrypt("HELLO", 3))

    print("\n=== Vigenere Cipher ===")
    print(vigenere_encrypt("HELLO", "KEY"))

    print("\n=== Affine Cipher ===")
    print(affine_encrypt("HELLO", 5, 8))

    print("\n=== Playfair Cipher ===")
    print(playfair_encrypt("HELLO", "KEYWORD"))

    print("\n=== Hill Cipher ===")
    key_matrix = np.array([[3, 3], [2, 5]])
    print(hill_encrypt("HELLO", key_matrix))
